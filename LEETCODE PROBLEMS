// 136.single number (unique number in the array)

int singleNumber(vector<int>& nums) {
        int ans=0;
        for(int value: nums){
            ans^=value;
        }
        return ans;
        
    }
------------------------------------------------------------------------------------
// 53. maximum Subarray (kadanes maxSum)

int maxSubArray(vector<int>& nums) {
        
        int currSum=0, maxSum=INT_MIN;

        for(int val: nums){
            currSum+=val;
            maxSum=max(currSum,maxSum);

            if(currSum<0){
                currSum=0;
            }   
        }
        return maxSum;
    }
--------------------------------------------------------------------
 121. Buy and Sell stock

int maxProfit(vector<int>& prices) {
        int maxProfit=0, bestBuy =prices[0];
        for (int i=1;i<prices.size();i++){
              
            maxProfit=max(maxProfit,prices[i]-bestBuy);
            
            bestBuy=min(bestBuy,prices[i]);
        }
        return maxProfit;      
    }
-----------------------------------------------------------------------------
11.Contain with most water
int maxArea(vector<int>& height) {
        int lp =0, rp=height.size()-1;int MaxWater =0;
        while (lp<rp){
            int w =rp-lp;
            int ht = min(height[lp],height[rp]);
            int currWater =w*ht;
            MaxWater=max(MaxWater,currWater);
            
            height[lp]<height[rp]?lp++:rp--;
        }
        return MaxWater;  
    }
--------------------------------------------------------------------------------------
33.search in the rotated sorted array
int search(vector<int>& nums, int target) {
        int n=nums.size();
        int low=0,high=n-1;

        while(low<=high){
            int mid=low+(high-low)/2;
            if(nums[mid]==target){
                return mid;
            }
            else if(nums[mid]>=nums[low]){
                if(target>=nums[low] && target<=nums[mid]){
                    high =mid-1;
                }
                else{low=mid+1;
                }
            }
            else{
                if(target>=nums[mid+1] && target<=nums[high]){
                    low=mid+1;
                }
                else{high =mid-1;
                }
            }
        }
        return -1;
    
    }
-----------------------------------------------------------------------------------
217.CONTAINS DUPLICATE
bool containsDuplicate(vector<int>& nums) {
        sort (nums.begin(),nums.end());
        for(int i=1;i<nums.size();i++){
            if(nums[i-1]==nums[i]){
                return true;
            }
        }
        return false;
}
---------------------------------------------------------------------------------------------

1.TWOSUM
 vector<int> twoSum(vector<int>& nums, int target) {
        for(int i=0;i<nums.size();i++){
            for(int j=i+1;j<nums.size();j++){
                if(nums[i]+nums[j]==target){
                    return {i,j};
                }
                
            }
        }
        
         return {};
        
    }
-----------------------------------------------------------------------------------
704.BINARY SEARCH
 int search(vector<int>& nums, int target) {
        int lb=0,ub=nums.size()-1;
        while(lb<=ub){
            int mid=lb+(ub-lb)/2;
            if(nums[mid]==target){
                return mid;
            }
            else if(nums[mid]<target){
                lb=mid+1;

            }
            else{
                ub=mid-1;
            }
        }
        return -1;
    }
